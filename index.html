<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/favicon.png" type="image/x-icon">

    <title>Interactive Guide to Turbo-C Graphics</title>
        <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            scroll-behavior: smooth;
        }
        .content-section {
            display: block;
            animation: fadeIn 0.5s ease-in-out;
            scroll-margin-top: 100px;
            padding-top: 40px;
            padding-bottom: 40px;
        }
        .nav-btn {
            transition: all 0.3s ease;
        }
        .nav-btn.active {
            background-color: rgb(146 64 14) !important;
            color: white !important;
        }
        .toggle-content {
            display: none;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
            max-height: 0;
        }
        .toggle-content.show {
            display: block;
            max-height: 1000px;
        }
        .toggle-icon {
            transition: transform 0.3s ease;
        }
        .rotated {
            transform: rotate(90deg);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        #hanoiCanvas {
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .chart-container {
            position: relative;
            width: 100%;
            height: 140px; /* default, can be overridden by inline style */
        }
        /* Mobile nav slide-down animation */
        .nav-links {
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            transition: max-height 0.4s ease-in-out, opacity 0.3s ease-in-out, padding 0.3s ease-in-out;
        }
        .nav-links.open {
            max-height: 400px;
            opacity: 1;
            padding-top: 1rem;
        }
        /* Tablet/Desktop: nav always visible */
        @media (min-width: 768px) {
            .nav-links {
                max-height: none !important;
                opacity: 1 !important;
                padding-top: 0 !important;
            }
        }
        /* Mobile responsiveness tweaks - refined breakpoints */
        @media (max-width: 767px) {
            /* Stack nav links when toggled; slide down animation via classes above */
            .nav-links { 
                flex-direction: column; 
                gap: 0.75rem; 
                align-items: stretch;
                padding-left: 0.5rem;
                padding-right: 0.5rem;
            }
            /* Adjust chart/canvas heights for mobile readability */
            .chart-container { height: 180px; }
            /* Responsive typography */
            h1, .text-4xl { font-size: 1.875rem !important; }
            h2, .text-3xl { font-size: 1.5rem !important; }
            h3, .text-2xl { font-size: 1.25rem !important; }
            h4, .text-xl { font-size: 1.125rem !important; }
            p, .text-lg { font-size: 1rem !important; }
            /* Reduce pre/code font size on small screens */
            pre { font-size: 11px; line-height: 1.4; padding: 0.5rem !important; }
            code { font-size: 0.875rem; }
            /* Make footer icons stack vertically on mobile */
            .footer-stack { flex-direction: column; gap: 0.75rem; }
            /* Tighter spacing for cards and sections */
            .content-section { padding-top: 1.5rem; padding-bottom: 1.5rem; scroll-margin-top: 80px; }
            .bg-white { padding: 1rem !important; }
            /* Button sizing on mobile */
            button, .nav-btn { font-size: 0.875rem; padding: 0.5rem 1rem; }
            /* Grid adjustments */
            .grid { gap: 1rem !important; }
            /* Section margins */
            header { margin-bottom: 2rem !important; }
            nav { margin-bottom: 2rem !important; }
        }
        /* Very small phones (320px-480px) */
        @media (max-width: 480px) {
            .chart-container { height: 200px; }
            h1, .text-4xl { font-size: 1.5rem !important; }
            pre { font-size: 10px; max-height: 180px !important; }
            .bg-white { padding: 0.75rem !important; }
            /* Extra compact spacing */
            .content-section { padding-top: 1rem; padding-bottom: 1rem; }
        }
    </style>
</head>
<body class="bg-amber-50 text-stone-800">
    <main class="container mx-auto p-4 md:p-8 max-w-6xl min-h-screen">
        <header class="text-center mb-6 md:mb-8 px-4">
            <a href="/" class="text-3xl md:text-4xl lg:text-5xl font-bold text-amber-800 mb-2 block">Interactive Guide to Turbo-C Graphics</a>
            <p class="text-base md:text-lg lg:text-xl text-stone-600">An exploration of the concepts from the classic <code class="bg-stone-200 px-2 py-1 rounded text-sm md:text-base">graphics.h</code> library</p>
        </header>

        <nav class="sticky top-0 z-50 bg-amber-50 py-4 -mx-4 px-4 md:-mx-8 md:px-8 mb-8 md:mb-12">
            <!-- Mobile nav toggle (visible on small screens) -->
            <div class="flex items-center justify-between md:hidden mb-2">
                <span class="text-sm font-semibold text-amber-800">Menu</span>
                <button id="mobileNavToggle" aria-controls="mainNavLinks" aria-expanded="false" class="p-2.5 rounded-lg bg-amber-100 text-amber-800 hover:bg-amber-200 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M3 6h18M3 12h18M3 18h18"/></svg>
                </button>
            </div>
            <div id="mainNavLinks" class="nav-links flex flex-wrap justify-center gap-2 md:gap-2">
                <a href="#home" class="nav-btn active text-white bg-amber-700 font-semibold text-sm py-1.5 px-3 md:py-2 md:px-5 rounded-full w-full md:w-auto text-center" data-target="home">Home</a>
                <a href="#structure" class="nav-btn bg-amber-100 text-amber-800 hover:bg-amber-200 font-semibold text-sm py-1.5 px-3 md:py-2 md:px-5 rounded-full w-full md:w-auto text-center" data-target="structure">0. Structure</a>
                <a href="#fundamentals" class="nav-btn bg-amber-100 text-amber-800 hover:bg-amber-200 font-semibold text-sm py-1.5 px-3 md:py-2 md:px-5 rounded-full w-full md:w-auto text-center" data-target="fundamentals">1. Fundamentals</a>
                <a href="#concepts" class="nav-btn bg-amber-100 text-amber-800 hover:bg-amber-200 font-semibold text-sm py-1.5 px-3 md:py-2 md:px-5 rounded-full w-full md:w-auto text-center" data-target="concepts">2. Core Concepts</a>
                <a href="#applications" class="nav-btn bg-amber-100 text-amber-800 hover:bg-amber-200 font-semibold text-sm py-1.5 px-3 md:py-2 md:px-5 rounded-full w-full md:w-auto text-center" data-target="applications">3. Applications</a>
            </div>
        </nav>

        <div id="content-container">
            
            
            <section id="home" class="content-section active">
                <h2 class="text-3xl font-bold text-amber-800 mb-4 text-center">Welcome to the Guide</h2>
                <p class="text-lg text-stone-700 max-w-3xl mx-auto text-center mb-8">
                    This application translates the core topics of the Turbo-C graphics language into an interactive, explorable format. Use the navigation above to move between sections and click on any topic to reveal more details.
                </p>
                <div class="grid md:grid-cols-2 gap-4 md:gap-6 max-w-4xl mx-auto">
                    <div class="bg-white p-4 md:p-8 rounded-xl shadow-lg border border-amber-100 flex items-center justify-center flex-col gap-3 md:gap-5">
                        <h3 class="text-xl md:text-2xl font-semibold text-amber-700 mb-2">What Was Turbo-C Graphics?</h3>
                        <p class="text-sm md:text-base text-stone-600">
                            The Turbo-C <code class="bg-stone-200 px-1 py-0.5 rounded">graphics.h</code> library was a popular and simple way for students and hobbyists in the late 1980s and 90s to learn computer graphics. It provided a set of functions to draw pixels, lines, circles, and rectangles, and to handle colors and basic animations, all within the MS-DOS environment.
                        </p>
                         <div>
                        <h3 class="text-xl md:text-2xl font-semibold text-amber-700 mb-2">Historical Context</h3>
                        <ul class="list-disc text-sm md:text-base pl-4">
                            <li>Turbo-C graphics.h was a lightweight graphics library bundled with the Turbo-C compiler.</li>
                            <li>It was widely used in the late 1980s and 1990s, especially in educational settings and hobbyist projects.</li>
                            <li>It operated within the MS-DOS environment, meaning it ran on early personal computers using command-line interfaces.</li>
        

                        </ul>
                    </div>
                    </div>
                    <div class="bg-white p-4 md:p-8 rounded-xl shadow-lg border border-amber-100">
                        <h3 class="text-xl md:text-2xl font-semibold text-amber-700 mb-2">Why It Still Matters?</h3>
                        <p class="text-sm md:text-base text-stone-600">
Although obsolete today, the guide emphasizes that Turbo-C graphics teaches fundamental concepts:
<ul class="list-disc pl-4 text-sm md:text-base">

<li>Primitives: How to build visuals from basic shapes.</li>

<li>Transformations: How to move, scale, and rotate objects.</li>

<li>Animation: How to simulate motion using variable updates and redraw cycles.</li>

<li>These ideas are foundational for understanding modern graphics engines, game development, and data visualization tools.</li>
 </ul>                       
</p>
                        
                    </div>
                   
                </div>
            </section>


            <section id="structure" class="content-section">
                <h2 class="text-2xl md:text-3xl font-bold text-amber-800 mb-4 text-center">Structure: Program Skeleton</h2>
                <div class="flex justify-center">
                    <div class="bg-white p-4 md:p-6 rounded-xl shadow-lg border border-amber-100 max-w-4xl w-full">
                        <h3 class="text-xl md:text-2xl font-semibold text-amber-700 mb-3">Minimal Turbo-C Graphics Program</h3>
                        <p class="text-sm md:text-base text-stone-600 mb-3">Below is a minimal program skeleton using the classic <code class="bg-stone-200 px-1 py-0.5 rounded text-xs md:text-sm">graphics.h</code> API. Each line includes an inline comment that explains its purpose.</p>
                        <pre id="structureCode" class="bg-stone-900 text-amber-100 p-3 rounded max-h-56 overflow-auto text-sm">#include &lt;graphics.h&gt;   // Provides the Turbo-C graphics API (putpixel, line, circle, etc.)
#include &lt;stdio.h&gt;      // Standard I/O (printf, etc.)
#include &lt;conio.h&gt;      // Console I/O helpers (getch)

int main() {
    int gd = DETECT, gm;                  // gd: graphics driver, gm: graphics mode; DETECT auto-selects driver
    initgraph(&gd, &gm, "");            // Initialize the graphics system and set video mode
    /* --- Place drawing calls here (putpixel, line, circle, rectangle, etc.) --- */
    getch();                              // Wait for a key press so the window stays visible
    closegraph();                         // Shut down graphics mode and restore normal console
    return 0;                             // Exit the program
}
</pre>

                        <div class="mt-4">
                            <h4 class="text-base md:text-lg font-semibold text-amber-800 mb-2">Program structure (overview)</h4>
                            <p class="text-sm md:text-base text-stone-600">This program demonstrates the typical lifecycle of a Turbo-C graphics application:</p>
                            <ol class="list-decimal list-inside text-sm md:text-base text-stone-600 space-y-2 pl-2">
                                <li><strong>Includes:</strong> Header files bring in the graphics API and any standard helpers you need.</li>
                                <li><strong>main:</strong> Entry point where you initialize the graphics driver and mode with <code class="bg-stone-200 px-1 py-0.5 rounded">initgraph()</code>.</li>
                                <li><strong>Drawing:</strong> Call drawing routines (putpixel, line, rectangle, circle, etc.) while the graphics mode is active.</li>
                                <li><strong>Wait:</strong> Use <code class="bg-stone-200 px-1 py-0.5 rounded">getch()</code> or a delay to allow the user to view the output.</li>
                                <li><strong>Cleanup:</strong> Call <code class="bg-stone-200 px-1 py-0.5 rounded">closegraph()</code> to return the machine to text mode and free resources.</li>
                            </ol>

                            <h5 class="font-semibold text-amber-800 mt-4 mb-2">Key graphics functions & keywords</h5>
                            <div class="space-y-2 text-stone-600">
                                <p><strong>DETECT</strong> — A special constant passed to <code class="bg-stone-200 px-1 py-0.5 rounded">initgraph()</code> that tells the library to auto-detect the best graphics driver for the environment.</p>
                                <p><strong>initgraph(int *gd, int *gm, const char *path)</strong> — Initializes the graphics system. Parameters are pointers to driver and mode variables; the path is an optional driver path in older implementations.</p>
                                <p><strong>closegraph()</strong> — Restores the display to the original text mode and releases graphics resources.</p>
                                <p><strong>putpixel(int x, int y, int color)</strong> — Draws a single pixel at coordinates (x,y) using the specified color.</p>
                                <p><strong>line(int x1, int y1, int x2, int y2)</strong> — Draws a straight line between two points; often implemented via Bresenham's algorithm.</p>
                                <p><strong>rectangle(int x1, int y1, int x2, int y2)</strong> — Draws an axis-aligned rectangle outline defined by the two corner coordinates.</p>
                                <p><strong>circle(int x, int y, int r)</strong> — Draws a circle with center (x,y) and radius r using an efficient midpoint algorithm.</p>
                                <p><strong>setfillstyle()</strong>, <strong>floodfill()</strong> — Used together to fill shapes with a pattern or color.</p>
                                <p><strong>getimage()</strong>, <strong>putimage()</strong> — Capture and restore rectangular regions of the screen (useful for sprites and saving parts of the display).</p>
                                <p><strong>cleardevice()</strong> — Clears the entire graphics screen (useful between animation frames).</p>
                                <p><strong>getch()</strong> — Waits for a key press (commonly used to pause the program so the output can be inspected).</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="fundamentals" class="content-section">
                <h2 class="text-3xl font-bold text-amber-800 mb-4 text-center">1. Fundamentals: The Building Blocks</h2>
                <p class="text-lg text-stone-700 max-w-3xl mx-auto text-center mb-8">
                    This section covers the absolute basics. "Primitives" are the foundational elements like variables and operators that define *what* you can draw, while "Plotting & Transformations" cover the actions of *how* you draw and manipulate those shapes on the screen.
                </p>
                <div class="grid md:grid-cols-2 gap-6">
                    <div class="bg-white p-6 rounded-xl shadow-lg border border-amber-100 md:col-span-2">
                        <h3 class="text-2xl font-semibold text-amber-700 mb-4">Turbo-C Graphics Language — Detailed Topics</h3>
                        <div class="space-y-4 text-stone-600">
                            <div>
                                <h4 class="font-semibold text-amber-800">Primitives (Constants, Actions, Operators, Variables)</h4>
                                <p class="mt-2">Primitives are the smallest building blocks: constants (predefined colors and styles), actions (system calls), the C operators used to compute positions, and the variables that hold state. Examples:
                                    <br>• <code class="bg-stone-200 px-1 py-0.5 rounded">RED, BLUE</code> — Used to specify colors and styles in drawing functions.
                                    <br>• <code class="bg-stone-200 px-1 py-0.5 rounded">initgraph()</code>, <code class="bg-stone-200 px-1 py-0.5 rounded">closegraph()</code> — actions to start/stop the driver. These are essential for setting up and tearing down the graphics environment.
                                    <br>• Operators like <code class="bg-stone-200 px-1 py-0.5 rounded">+</code> and <code class="bg-stone-200 px-1 py-0.5 rounded">*</code> are used to compute coordinates (e.g., centerX = x + width/2).
                                    <br>• Variables store coordinates, sizes, colors, and animation state. Store dynamic state like coordinates, sizes, colors, and animation parameters. (for example <code class="bg-stone-200 px-1 py-0.5 rounded">int x, y, radius, color;</code>).</p>
                            </div>

                            <div>
                                <h4 class="font-semibold text-amber-800">Plotting & Geometric Transformations</h4>
                                <p class="mt-2">Plotting functions draw primitives on the screen. Typical functions include:
                                    <br>• <code class="bg-stone-200 px-1 py-0.5 rounded">putpixel(x, y, color)</code>
                                    <br>• <code class="bg-stone-200 px-1 py-0.5 rounded">line(x1, y1, x2, y2)</code>
                                    <br>• <code class="bg-stone-200 px-1 py-0.5 rounded">rectangle(x1, y1, x2, y2)</code>
                                    <br>• <code class="bg-stone-200 px-1 py-0.5 rounded">circle(x, y, r)</code>
                                    <br>Transformations are implemented by changing coordinates before drawing:</p>
                                <div class="mt-3 space-y-2 bg-amber-50 p-3 rounded-lg border border-amber-200">
                                    <div class="flex items-start">
                                        <span class="mr-2">•</span>
                                        <p><strong class="text-amber-800">Translation:</strong> <code class="bg-white px-2 py-1 rounded border border-amber-200">(x', y') = (x + tx, y + ty)</code></p>
                                    </div>
                                    <div class="flex items-start">
                                        <span class="mr-2">•</span>
                                        <p><strong class="text-amber-800">Scaling:</strong> <code class="bg-white px-2 py-1 rounded border border-amber-200">(x', y') = (cx + sx*(x-cx), cy + sy*(y-cy))</code></p>
                                    </div>
                                    <div class="flex items-start">
                                        <span class="mr-2">•</span>
                                        <p><strong class="text-amber-800">Rotation:</strong> <code class="bg-white px-2 py-1 rounded border border-amber-200">(x', y') = (cx + (x-cx)*cosθ - (y-cy)*sinθ, cy + (x-cx)*sinθ + (y-cy)*cosθ)</code></p>
                                    </div>

                                    <p class="text-stone-600">In Turbo-C, transformations were often done manually by changing the variables used for plotting.
                                        <br><strong>Translation (Moving):</strong> Adding an offset to an object's (x, y) coordinates before redrawing it.
                                        <br><strong>Scaling (Resizing):</strong> Multiplying an object's width and height by a factor.
                                        <br><strong>Rotation:</strong> Applying trigonometric functions (sine, cosine) to an object's coordinates to calculate its new position around a central point.
                                    </p>
                                </div>
                            </div>
                            <!-- Quick C examples + static previews for plotting primitives -->
                                    <div class="mt-4 border-t pt-4">
                                        <div class="flex flex-wrap gap-2 items-center mb-3">
                                            <button class="bg-amber-100 text-amber-800 font-semibold py-1 px-3 rounded show-code text-sm" data-code="putpixel">putpixel()</button>
                                            <button class="bg-amber-100 text-amber-800 font-semibold py-1 px-3 rounded show-code text-sm" data-code="line">line()</button>
                                            <button class="bg-amber-100 text-amber-800 font-semibold py-1 px-3 rounded show-code text-sm" data-code="rectangle">rectangle()</button>
                                            <button class="bg-amber-100 text-amber-800 font-semibold py-1 px-3 rounded show-code text-sm" data-code="circle">circle()</button>
                                        </div>

                                        <div class="grid md:grid-cols-2 gap-4">
                                            <div>
                                                <label class="text-sm font-semibold text-amber-800">C Example</label>
                                                <pre id="plottingCode" class="bg-stone-900 text-amber-100 p-3 rounded max-h-48 overflow-auto text-sm">Click a function above to view a short C example.</pre>
                                            </div>
                                            <div>
                                                <label class="text-sm font-semibold text-amber-800">Static Output Preview</label>
                                                <div id="plottingPreview" class="mt-2 p-2 bg-white rounded border border-amber-100"></div>
                                            </div>
                                        </div>
                                    </div>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-xl shadow-lg border border-amber-100">
                        <h3 class="text-2xl font-semibold text-amber-700 mb-4">Primitives</h3>
                        <div class="space-y-3">
                            <div class="border rounded-lg overflow-hidden">
                                <button class="flex justify-between items-center w-full p-4 bg-amber-50 hover:bg-amber-100" data-toggle="prim-constants">
                                    <span class="font-semibold text-lg text-amber-800">Constants & Actions</span>
                                    <span class="toggle-icon text-amber-800 font-bold text-xl">►</span>
                                </button>
                                <div class="toggle-content p-4 bg-white" id="prim-constants">
                                    <p class="text-stone-600">These are predefined values that control the graphics system. <br>
                                        <strong>Constants:</strong> Values for colors (e.g., <code class="bg-stone-200 px-1 py-0.5 rounded">RED</code>, <code class="bg-stone-200 px-1 py-0.5 rounded">BLUE</code>), fill patterns, and line styles. <br>
                                        <strong>Actions:</strong> Functions that initialize the system (e.g., <code class="bg-stone-200 px-1 py-0.5 rounded">initgraph()</code>) or close it (e.g., <code class="bg-stone-200 px-1 py-0.5 rounded">closegraph()</code>).
                                    <!-- saving/loading demo moved to Core Concepts to keep interactive examples together -->
                                    <p class="text-stone-600">These aren't new operators, but rather how standard C operators (like <code class="bg-stone-200 px-1 py-0.5 rounded">+</code>, <code class="bg-stone-200 px-1 py-0.5 rounded">-</code>, <code class="bg-stone-200 px-1 py-0.5 rounded">*</code>, <code class="bg-stone-200 px-1 py-0.5 rounded">/</code>) are used to calculate coordinates, sizes, and new positions for drawing and animation.
                                    </p>
                                </div>
                            </div>
                            <div class="border rounded-lg overflow-hidden">
                                <button class="flex justify-between items-center w-full p-4 bg-amber-50 hover:bg-amber-100" data-toggle="prim-variables">
                                    <span class="font-semibold text-lg text-amber-800">Variables</span>
                                    <span class="toggle-icon text-amber-800 font-bold text-xl">►</span>
                                </button>
                                <div class="toggle-content p-4 bg-white" id="prim-variables">
                                    <p class="text-stone-600">Variables are essential for dynamic graphics. They store screen coordinates (x, y), object properties (width, height, radius), and state (current color, position, velocity). Animation is impossible without them.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-xl shadow-lg border border-amber-100">
                        <h3 class="text-2xl font-semibold text-amber-700 mb-4">Plotting & Transformations</h3>
                        <div class="space-y-3">
                            <div class="border rounded-lg overflow-hidden">
                                <button class="flex justify-between items-center w-full p-4 bg-amber-50 hover:bg-amber-100" data-toggle="plot-plotting">
                                    <span class="font-semibold text-lg text-amber-800">Plotting</span>
                                    <span class="toggle-icon text-amber-800 font-bold text-xl">►</span>
                                </button>
                                <div class="toggle-content p-4 bg-white" id="plot-plotting">
                                    <p class="text-stone-600">This refers to the core drawing commands:
                                        <br>• <code class="bg-stone-200 px-1 py-0.5 rounded">putpixel(x, y, color)</code>: The most basic, draws a single dot.
                                        <br>• <code class="bg-stone-200 px-1 py-0.5 rounded">line(x1, y1, x2, y2)</code>: Draws a line between two points.
                                        <br>• <code class="bg-stone-200 px-1 py-0.5 rounded">rectangle(x1, y1, x2, y2)</code>: Draws a box.
                                        <br>• <code class="bg-stone-200 px-1 py-0.5 rounded">circle(x, y, radius)</code>: Draws a circle.
                                        <br>• <code class="bg-stone-200 px-1 py-0.5 rounded">setfillstyle()</code> & <code class="bg-stone-200 px-1 py-0.5 rounded">floodfill()</code>: Used to fill enclosed shapes with color.
                                    </p>
                                </div>
                            </div>
                            <div class="border rounded-lg overflow-hidden">
                                <button class="flex justify-between items-center w-full p-4 bg-amber-50 hover:bg-amber-100" data-toggle="plot-transforms">
                                    <span class="font-semibold text-lg text-amber-800">Geometric Transformations</span>
                                    <span class="toggle-icon text-amber-800 font-bold text-xl">►</span>
                                </button>
                                <div class="toggle-content p-4 bg-white" id="plot-transforms">
                                    <p class="text-stone-600">In Turbo-C, transformations were often done manually by changing the variables used for plotting.
                                        <br><strong>Translation (Moving):</strong> Adding an offset to an object's (x, y) coordinates before redrawing it.
                                        <br><strong>Scaling (Resizing):</strong> Multiplying an object's width and height by a factor.
                                        <br><strong>Rotation:</strong> Applying trigonometric functions (sine, cosine) to an object's coordinates to calculate its new position around a central point.
                                    </p>
                                    
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="concepts" class="content-section">
                <h2 class="text-2xl md:text-3xl font-bold text-amber-800 mb-4 text-center">2. Core Concepts: Structure & Motion</h2>
                <p class="text-base md:text-lg text-stone-700 max-w-3xl mx-auto text-center mb-6 md:mb-8 px-4">
                    Once you have the fundamentals, the next step is organization and dynamism. "Display Subroutines" explore how to create reusable drawing functions, while the "Concept of Animation" shows how to string individual drawings together to create the illusion of movement.
                </p>
                <div class="space-y-4 md:space-y-6">
                    <!-- Display Subroutines - Centered with increased width -->
                    <div class="flex justify-center">
                        <div class="bg-white p-4 md:p-6 rounded-xl shadow-lg border border-amber-100 max-w-4xl w-full">
                            <h3 class="text-xl md:text-2xl font-semibold text-amber-700 mb-3 md:mb-4">Display Subroutines</h3>
                            <p class="text-sm md:text-base text-stone-600">
                                These are simply C functions that bundle drawing commands. Instead of writing the code for a car 10 times, you would create a single function: <code class="bg-stone-200 px-1 py-0.5 rounded text-xs md:text-sm">void drawCar(int x, int y, int color)</code>.
                                <br><br>
                                This function would contain all the <code class="bg-stone-200 px-1 py-0.5 rounded text-xs md:text-sm">line()</code> and <code class="bg-stone-200 px-1 py-0.5 rounded text-xs md:text-sm">circle()</code> calls needed to draw a car at the given (x, y) position. This makes code reusable, readable, and much easier to manage, especially for complex scenes or animations.
                            </p>
                        </div>
                    </div>

                    <!-- Interactive Demos - Full width -->
                    <div class="bg-white p-4 md:p-6 rounded-xl shadow-lg border border-amber-100">
                        <h3 class="text-xl md:text-2xl font-semibold text-amber-700 mb-3 md:mb-4">Interactive Demos & Turbo-C Program Screen</h3>
                        <p class="text-sm md:text-base text-stone-600 mb-3 md:mb-4">Live demos are grouped here so you can run the animation, inspect the step log, and view a small Turbo-C program that implements the same idea.</p>

                        <div class="grid md:grid-cols-3 gap-3 md:gap-4">
                            <!-- Animation concept -->
                            <div class="p-3 bg-stone-50 rounded-lg border">
                                <h4 class="font-semibold text-amber-800 mb-2">Concept of Animation</h4>
                                <div class="chart-container bg-white rounded-md p-2 h-36 md:h-44">
                                    <canvas id="animConceptCanvas"></canvas>
                                </div>
                                <div class="flex gap-2 mt-3">
                                    <button id="animStartBtn2" class="bg-amber-700 text-white font-semibold py-1 px-3 rounded-full">Start</button>
                                    <button id="animStopBtn2" class="bg-amber-100 text-amber-800 font-semibold py-1 px-3 rounded-full">Stop</button>
                                    <button class="bg-amber-100 text-amber-800 font-semibold py-1 px-3 rounded-full show-code" data-code="anim">Show Code</button>
                                </div>
                                <div id="anim-steps-2" class="text-sm text-stone-600 mt-2 h-24 overflow-y-auto p-2 bg-stone-50 rounded-md border">Steps will appear here...</div>
                            </div>

                            <!-- Save / Load demo -->
                            <div class="p-3 bg-stone-50 rounded-lg border">
                                <h4 class="font-semibold text-amber-800 mb-2">Saving & Loading</h4>
                                <div class="chart-container bg-white rounded-md p-2 h-36 md:h-44">
                                    <canvas id="saveLoadCanvas2"></canvas>
                                </div>
                                <div class="flex gap-1 mt-3">
                                    <button id="saveImgBtn2" class="bg-amber-700 text-white font-semibold py-1 px-2 rounded text-sm">Save</button>
                                    <label class="bg-amber-100 text-amber-800 font-semibold py-1 px-2 rounded cursor-pointer text-sm">
                                        Load
                                        <input id="loadImgInput2" type="file" accept="image/*" style="display:none">
                                    </label>
                                    <button class="bg-amber-100 text-amber-800 font-semibold py-1 px-2 rounded show-code text-sm" data-code="save">Code</button>
                                </div>
                            </div>

                            <!-- Towers of Hanoi -->
                            <div class="p-3 bg-stone-50 rounded-lg border">
                                <h4 class="font-semibold text-amber-800 mb-2">Towers of Hanoi</h4>
                                <div class="chart-container bg-white rounded-md p-2 h-36 md:h-44">
                                    <canvas id="hanoiCanvas2"></canvas>
                                </div>
                                <div class="flex gap-2 mt-3">
                                    <button id="animateHanoiBtn2" class="bg-amber-700 text-white font-semibold py-1 px-3 rounded-full">Animate (3)</button>
                                    <button class="bg-amber-100 text-amber-800 font-semibold py-1 px-3 rounded-full show-code" data-code="hanoi">Show Code</button>
                                </div>
                                <div id="hanoi-steps-2" class="text-sm text-stone-600 mt-2 h-24 overflow-y-auto p-2 bg-stone-50 rounded-md border">Steps will appear here...</div>
                            </div>
                        </div>

                        <div id="demoStatus" class="mt-3 text-sm text-stone-500">Demo status: initializing...</div>

                        <div class="mt-3 md:mt-4">
                            <h4 class="font-semibold text-amber-800 mb-2 text-sm md:text-base">Turbo-C Example (Program Screen)</h4>
                            <pre id="tcCode" class="bg-stone-900 text-amber-100 p-2 md:p-3 rounded max-h-48 overflow-auto text-xs md:text-sm">// Select a demo and click "Show Code" to view a small Turbo-C program here.</pre>
                            <!-- Primitive functions preview (static image) -->
                            <div id="primitivePreview" class="mt-2 md:mt-3 p-2 md:p-3 bg-white rounded border border-amber-100 hidden"></div>
                        </div>
                    </div>

                    <!-- Concept of Animation - Centered with increased width -->
                    <div class="flex justify-center">
                        <div class="bg-white p-4 md:p-6 rounded-xl shadow-lg border border-amber-100 max-w-4xl w-full">
                            <h3 class="text-xl md:text-2xl font-semibold text-amber-700 mb-3 md:mb-4">Concept of Animation</h3>
                            <p class="text-sm md:text-base text-stone-600">
                                Animation in Turbo-C was a manual process that created an illusion of motion. It was achieved through a simple, repetitive loop:
                                <br><br>
                                <ol class="list-decimal list-inside space-y-2 pl-4 text-sm md:text-base">
                                    <li><strong>Draw:</strong> Call your display subroutines (e.g., <code class="bg-stone-200 px-1 py-0.5 rounded text-xs md:text-sm">drawCar(x, y)</code>) to draw the object at its current position.</li>
                                    <li><strong>Delay:</strong> Use a function like <code class="bg-stone-200 px-1 py-0.5 rounded text-xs md:text-sm">delay(milliseconds)</code> to pause execution briefly, allowing the human eye to see the frame.</li>
                                    <li><strong>Clear:</strong> Erase the object by drawing it again in the background color, or clear the entire screen with <code class="bg-stone-200 px-1 py-0.5 rounded text-xs md:text-sm">cleardevice()</code>.</li>
                                    <li><strong>Update:</strong> Change the variables that control the object's state (e.g., <code class="bg-stone-200 px-1 py-0.5 rounded text-xs md:text-sm">x = x + 1</code> to move it to the right).</li>
                                    <li><strong>Repeat:</strong> Loop back to step 1.</li>
                                </ol>
                            </p>
                        </div>
                    </div>
                </div>
            </section>

            <section id="applications" class="content-section">
                <h2 class="text-2xl md:text-3xl font-bold text-amber-800 mb-4 text-center">3. Applications: Bringing it to Life</h2>
                <p class="text-base md:text-lg text-stone-700 max-w-3xl mx-auto text-center mb-6 md:mb-8 px-4">
                    This is where the concepts come together. We'll look at how to persist your creations by saving and loading them, and explore how animation can be used to visualize complex processes, like sorting algorithms or the classic "Towers of Hanoi" puzzle.
                </p>
                
                <!-- Saving, Loading & Printing -->
                <div class="flex justify-center mb-6">
                    <div class="bg-white p-4 md:p-6 rounded-xl shadow-lg border border-amber-100 max-w-4xl w-full">
                        <h3 class="text-xl md:text-2xl font-semibold text-amber-700 mb-3 md:mb-4">Saving, Loading & Printing</h3>
                        <p class="text-sm md:text-base text-stone-600">
                            Turbo-C provided functions to save a part of the screen to disk and load it back later.
                            <br><br>
                            • <code class="bg-stone-200 px-1 py-0.5 rounded text-xs md:text-sm">getimage()</code> was used to capture a rectangular area of the screen and store it in memory.
                            <br>• <code class="bg-stone-200 px-1 py-0.5 rounded text-xs md:text-sm">putimage()</code> would draw that stored image back onto the screen.
                            <br><br>
                            By writing the in-memory data to a file, you could "save" an image. Reading it back from the file and using <code class="bg-stone-200 px-1 py-0.5 rounded text-xs md:text-sm">putimage()</code> would "load" it. "Printing" was more complex, often requiring third-party libraries or writing raw data to the printer port.
                        </p>
                    </div>
                </div>

                <!-- Animated Sorting - Bubble Sort -->
                <div class="flex justify-center">
                    <div class="bg-white p-3 md:p-5 rounded-xl shadow-lg border border-amber-100 max-w-4xl w-full">
                        <h3 class="text-lg md:text-xl font-semibold text-amber-700 mb-2 md:mb-3">Animated Sorting</h3>
                        <p class="text-xs md:text-sm text-stone-600 mb-3">
                            The same animation loop could be used to visualize algorithms. For a Bubble Sort, you would draw an array of vertical bars representing numbers. When the algorithm swapped two numbers, you would animate the two corresponding bars moving to their new positions, helping the programmer "see" the algorithm work.
                        </p>
                        
                        <div class="p-2 md:p-3 bg-stone-50 rounded-lg border border-amber-100">
                            <h4 class="font-semibold text-amber-800 mb-1.5 text-xs md:text-sm">Bubble Sort — Visualization & Localized Redraw</h4>
                            <p class="text-stone-600 text-xs mb-2">Visualizing sorting algorithms is a classic application of BGI, translating computational complexity and data rearrangement into dynamic graphical changes. The Bubble Sort algorithm, known for its iterative comparison and swapping of adjacent elements, serves as a strong pedagogical example.</p>
                            
                            <div class="grid md:grid-cols-2 gap-2 md:gap-3">
                                <div>
                                    <p class="text-stone-600 text-xs font-semibold mb-1">A. Visualization Mapping</p>
                                    <p class="text-stone-600 text-xs mb-2">Array elements are represented as vertical bars: the bar height maps to the numerical value, and the horizontal x-position maps to the index. During comparisons, the two bars are highlighted; on swaps the bars are redrawn at their new positions.</p>

                                    <p class="text-stone-600 text-xs mt-2 font-semibold mb-1">B. Implementation Strategy</p>
                                    <p class="text-stone-600 text-xs">To avoid flicker and reduce CPU work, the demo uses localized redraw: only the bar rectangles for indices being compared/swapped are erased and redrawn. A short <code class="bg-stone-200 px-0.5 py-0.5 rounded text-xs">delay()</code>-like pause is used between compare/erase/draw steps to make the animation perceptible.</p>
                                </div>

                                <div>
                                    <div class="flex flex-wrap gap-1.5 items-center mb-2">
                                        <button id="shuffleBubbleBtn" class="bg-amber-100 text-amber-800 font-semibold py-1 px-2.5 rounded text-xs">Shuffle</button>
                                        <button id="startBubbleBtn" class="bg-amber-700 text-white font-semibold py-1 px-2.5 rounded text-xs">Start</button>
                                        <button id="stopBubbleBtn" class="bg-amber-100 text-amber-800 font-semibold py-1 px-2.5 rounded text-xs">Stop</button>
                                        <button class="bg-amber-100 text-amber-800 font-semibold py-1 px-2.5 rounded show-code text-xs" data-code="bubblesort">Show C Code</button>
                                    </div>

                                    <div class="chart-container bg-white rounded-md p-1.5" style="height:150px">
                                        <canvas id="bubbleSortCanvas"></canvas>
                                    </div>
                                    <div id="bubbleSteps" class="text-xs text-stone-600 mt-1.5 h-16 md:h-20 overflow-y-auto p-1.5 bg-stone-50 rounded-md border">Click Shuffle to randomize, then Start to animate Bubble Sort.</div>
                                    <div id="bubbleValues" class="text-xs text-stone-600 mt-1.5 p-1.5 bg-stone-50 rounded-md border">Initial values will appear here.</div>
                                    <label class="text-xs font-semibold text-amber-800 mt-2 block">Bubble Sort C Example</label>
                                    <pre id="bubbleCode" class="bg-stone-900 text-amber-100 p-2 rounded max-h-32 md:max-h-40 overflow-x-auto overflow-y-auto text-xs whitespace-pre-wrap break-words">// Click "Show C Code" to view the Bubble Sort example here.</pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <footer class="bg-[#92400e] text-white border-t border-[#7a2f09] mt-6 md:mt-8">
        <div class="container mx-auto p-4 md:p-6 max-w-6xl text-center">
            <div class="flex items-center justify-center gap-3 md:gap-4 mb-2 md:mb-3 footer-stack">
                <a href="https://rahulkumarpahwa.tech" aria-label="Website" target="_blank" rel="noopener noreferrer" class="text-white hover:text-[#fffbeb]">
                    <!-- Globe SVG -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20zm6.9 6h-2.07a15.9 15.9 0 0 0-1.07-3.12A8.02 8.02 0 0 1 18.9 8zM12 4c.86 0 1.97 2.18 2.55 5H9.45C10.03 6.18 11.14 4 12 4zM4.1 8a8.02 8.02 0 0 1 3.14-3.12A15.9 15.9 0 0 0 5.1 8zM4.1 16a15.9 15.9 0 0 0 2.14 3.12A8.02 8.02 0 0 1 4.1 16zM12 20c-.86 0-1.97-2.18-2.55-5h5.1C13.97 17.82 12.86 20 12 20zm4.45-1.88c.44-.9.76-1.92.95-3.12h2.07a8.02 8.02 0 0 1-3.02 3.12zM16.55 12c0-1.6-.2-3.09-.55-4.4H8c-.35 1.31-.55 2.8-.55 4.4s.2 3.09.55 4.4h8c.35-1.31.55-2.8.55-4.4z"/></svg>
                </a>

                <a href="https://github.com/rahulkumarpahwa" aria-label="GitHub" target="_blank" rel="noopener noreferrer" class="text-white hover:text-[#fffbeb]">
                    <!-- GitHub SVG -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M12 .5C5.73.5.5 5.73.5 12c0 5.08 3.29 9.38 7.86 10.89.58.11.79-.25.79-.56 0-.28-.01-1.02-.01-2-3.2.69-3.88-1.42-3.88-1.42-.53-1.35-1.3-1.71-1.3-1.71-1.06-.72.08-.7.08-.7 1.17.08 1.79 1.2 1.79 1.2 1.04 1.78 2.73 1.27 3.4.97.11-.75.41-1.27.75-1.56-2.55-.29-5.24-1.28-5.24-5.7 0-1.26.45-2.29 1.19-3.1-.12-.29-.52-1.45.11-3.02 0 0 .97-.31 3.18 1.18a11.1 11.1 0 0 1 2.9-.39c.98 0 1.97.13 2.9.39 2.2-1.5 3.17-1.18 3.17-1.18.63 1.57.23 2.73.11 3.02.74.81 1.19 1.84 1.19 3.1 0 4.43-2.69 5.4-5.25 5.68.42.36.8 1.08.8 2.18 0 1.57-.01 2.84-.01 3.23 0 .31.21.68.8.56A10.52 10.52 0 0 0 23.5 12C23.5 5.73 18.27.5 12 .5z"/></svg>
                </a>

                <a href="https://linkedin.com/in/rahulkumarpahwa" aria-label="LinkedIn" target="_blank" rel="noopener noreferrer" class="text-white hover:text-[#fffbeb]">
                    <!-- LinkedIn SVG -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M4.98 3.5C4.98 4.88 3.87 6 2.49 6S0 4.88 0 3.5 1.11 1 2.49 1 4.98 2.12 4.98 3.5zM.24 8.98h4.5V24h-4.5V8.98zM9.5 8.98h4.32v2.04h.06c.6-1.14 2.06-2.34 4.25-2.34 4.55 0 5.39 2.99 5.39 6.88V24h-4.5v-7.26c0-1.73-.03-3.96-2.41-3.96-2.41 0-2.78 1.88-2.78 3.83V24H9.5V8.98z"/></svg>
                </a>

                <a href="https://x.com/rahulkumarpahwa" aria-label="X (Twitter)" target="_blank" rel="noopener noreferrer" class="text-white hover:text-[#fffbeb]">
                    <!-- X / Twitter SVG -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M22.46 6c-.77.35-1.6.58-2.46.69a4.28 4.28 0 0 0 1.88-2.37 8.59 8.59 0 0 1-2.71 1.04 4.28 4.28 0 0 0-7.3 3.9A12.14 12.14 0 0 1 3.15 4.6a4.28 4.28 0 0 0 1.32 5.72 4.22 4.22 0 0 1-1.94-.54v.05a4.28 4.28 0 0 0 3.43 4.2 4.3 4.3 0 0 1-1.93.07 4.28 4.28 0 0 0 3.99 2.97A8.59 8.59 0 0 1 2 19.54a12.1 12.1 0 0 0 6.56 1.92c7.88 0 12.2-6.53 12.2-12.2 0-.19 0-.39-.01-.58A8.7 8.7 0 0 0 22.46 6z"/></svg>
                </a>
            </div>

            <div class="text-sm text-white">&copy; Rahul Kumar Pahwa 2025-26</div>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const navButtons = document.querySelectorAll('.nav-btn');
            const contentSections = document.querySelectorAll('.content-section');
            
            // Intersection Observer for automatic active state on scroll
            const observerOptions = {
                root: null,
                rootMargin: '-20% 0px -60% 0px',
                threshold: 0
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const sectionId = entry.target.id;
                        navButtons.forEach(btn => {
                            const targetId = btn.getAttribute('data-target');
                            if (targetId === sectionId) {
                                btn.classList.add('active', 'bg-amber-700', 'text-white');
                                btn.classList.remove('bg-amber-100', 'text-amber-800');
                            } else {
                                btn.classList.remove('active', 'bg-amber-700', 'text-white');
                                btn.classList.add('bg-amber-100', 'text-amber-800');
                            }
                        });
                    }
                });
            }, observerOptions);

            // Observe all content sections
            contentSections.forEach(section => {
                observer.observe(section);
            });
            
            const togglers = document.querySelectorAll('[data-toggle]');
            
            togglers.forEach(toggler => {
                toggler.addEventListener('click', () => {
                    const targetId = toggler.getAttribute('data-toggle');
                    const targetContent = document.getElementById(targetId);
                    const icon = toggler.querySelector('.toggle-icon');
                    
                    if (targetContent) {
                        targetContent.classList.toggle('show');
                        icon.classList.toggle('rotated');
                    }
                });
            });

            // Towers of Hanoi (moved into Core Concepts): use new IDs with suffix 2
            const canvas = document.getElementById('hanoiCanvas2');
            const ctx = canvas ? canvas.getContext('2d') : null;
            const animateBtn = document.getElementById('animateHanoiBtn2');
            const stepsDiv = document.getElementById('hanoi-steps-2');

            const numDisks = 3;
            const diskColors = ['#dc2626', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6'];
            const pegWidth = 10;
            const diskHeight = 20;
            const pegNames = ['A', 'B', 'C'];
            
            let canvasWidth, canvasHeight;
            let pegs = [];
            let moves = [];
            let animationInterval = null;
            let isAnimating = false;

            function initialize() {
                if (animationInterval) {
                    clearInterval(animationInterval);
                }
                isAnimating = false;
                animateBtn.disabled = false;
                animateBtn.textContent = 'Animate (3 Disks)';
                moves = [];
                pegs = [
                    Array.from({ length: numDisks }, (_, i) => numDisks - i),
                    [],
                    []
                ];
                stepsDiv.innerHTML = 'Click "Animate" to start the simulation.';
                if (canvas && ctx) {
                    resizeCanvas();
                    draw();
                }
            }

            function resizeCanvas() {
                // devicePixelRatio-aware resize
                const dpr = window.devicePixelRatio || 1;
                const cssW = canvas.clientWidth;
                const cssH = canvas.clientHeight;
                canvas.width = Math.max(1, Math.floor(cssW * dpr));
                canvas.height = Math.max(1, Math.floor(cssH * dpr));
                // use CSS pixels for layout math and scale the context
                canvasWidth = cssW;
                canvasHeight = cssH;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                draw();
            }

            function draw() {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                ctx.fillStyle = '#f5f5f4';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                
                const pegHeight = canvasHeight * 0.7;
                const pegY = canvasHeight * 0.85;
                const baseWidth = canvasWidth * 0.9;
                const baseHeight = 10;
                
                ctx.fillStyle = '#57534e';
                ctx.fillRect((canvasWidth - baseWidth) / 2, pegY, baseWidth, baseHeight);
                
                for (let i = 0; i < 3; i++) {
                    const pegX = canvasWidth * (0.2 + i * 0.3);
                    ctx.fillRect(pegX - pegWidth / 2, pegY - pegHeight, pegWidth, pegHeight);
                    
                    pegs[i].forEach((diskSize, j) => {
                        drawDisk(i, j, diskSize);
                    });
                }
            }

            function drawDisk(pegIndex, diskIndex, diskSize) {
                const maxDiskWidth = canvasWidth / 3.5;
                const minDiskWidth = 30;
                const diskWidth = minDiskWidth + (maxDiskWidth - minDiskWidth) * (diskSize - 1) / (numDisks - 1);
                const pegX = canvasWidth * (0.2 + pegIndex * 0.3);
                const diskY = canvasHeight * 0.85 - (diskIndex + 1) * (diskHeight + 2);
                
                ctx.fillStyle = diskColors[diskSize - 1] || '#333';
                ctx.fillRect(pegX - diskWidth / 2, diskY, diskWidth, diskHeight);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(diskSize, pegX, diskY + diskHeight / 2);
            }

            function hanoi(n, from, to, aux) {
                if (n > 0) {
                    hanoi(n - 1, from, aux, to);
                    moves.push({ from, to });
                    hanoi(n - 1, aux, to, from);
                }
            }

            function animate() {
                if (isAnimating || !moves.length) {
                    isAnimating = false;
                    animateBtn.disabled = false;
                    animateBtn.textContent = 'Reset';
                    if (animationInterval) clearInterval(animationInterval);
                    return;
                }

                const move = moves.shift();
                const disk = pegs[move.from].pop();
                pegs[move.to].push(disk);
                
                draw();
                
                stepsDiv.innerHTML += `Move disk ${disk} from Peg ${pegNames[move.from]} to Peg ${pegNames[move.to]}<br>`;
                stepsDiv.scrollTop = stepsDiv.scrollHeight;
            }

            if (animateBtn) {
                animateBtn.addEventListener('click', () => {
                    if (isAnimating) return;

                    if (animateBtn.textContent === 'Reset') {
                        initialize();
                        return;
                    }
                    
                    initialize();
                    hanoi(numDisks, 0, 2, 1);
                    
                    isAnimating = true;
                    animateBtn.disabled = true;
                    animateBtn.textContent = 'Animating...';
                    stepsDiv.innerHTML = '';
                    
                    animationInterval = setInterval(animate, 1000);
                });
            }

            if (canvas && ctx) window.addEventListener('resize', resizeCanvas);
            // delay initialization to ensure DOM is fully ready
            setTimeout(() => {
                initialize();
            }, 50);
        });
    </script>
    <script>
        // Consolidated interactive demos script (animation, save/load/capture, and code viewer)
        document.addEventListener('DOMContentLoaded', () => {
            const demoStatus = document.getElementById('demoStatus');

            // Mobile nav toggle wiring: toggles the nav-links container on small screens
            (function setupMobileNavToggle() {
                const mobileToggle = document.getElementById('mobileNavToggle');
                const navLinks = document.getElementById('mainNavLinks');
                if (!mobileToggle || !navLinks) return;
                mobileToggle.addEventListener('click', () => {
                    const open = navLinks.classList.toggle('open');
                    mobileToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
                });
            })();

            // --- Animation concept demo ---
            (function setupAnimation() {
                const animCanvas = document.getElementById('animConceptCanvas') || document.getElementById('animConceptCanvas2');
                const animStartBtn = document.getElementById('animStartBtn2') || document.getElementById('animStartBtn');
                const animStopBtn = document.getElementById('animStopBtn2') || document.getElementById('animStopBtn');
                const animSteps = document.getElementById('anim-steps-2') || document.getElementById('anim-steps');
                if (!animCanvas || !animStartBtn || !animStopBtn || !animSteps) return;

                const ctx = animCanvas.getContext('2d');
                let cssW = 0, cssH = 0, dpr = 1;
                function resize() {
                    dpr = window.devicePixelRatio || 1;
                    cssW = animCanvas.clientWidth;
                    cssH = animCanvas.clientHeight;
                    animCanvas.width = Math.max(1, Math.floor(cssW * dpr));
                    animCanvas.height = Math.max(1, Math.floor(cssH * dpr));
                    // work in CSS pixels by scaling the context
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                }

                let x = 40, vx = 2, radius = 12;
                let running = false;
                let raf = null;

                function draw() {
                    // clear using CSS coordinates
                    ctx.clearRect(0, 0, cssW, cssH);
                    // background
                    ctx.fillStyle = '#fff7ed';
                    ctx.fillRect(0, 0, cssW, cssH);
                    // disk
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(x, cssH / 2, radius, 0, Math.PI * 2);
                    ctx.fill();

                    animSteps.innerHTML = 'Draw → Delay → Clear → Update<br>' +
                        `Position: ${Math.round(x)}, Velocity: ${vx}`;

                    x += vx;
                    if (x + radius > cssW || x - radius < 0) vx = -vx;

                    if (running) raf = requestAnimationFrame(draw);
                }

                animStartBtn.addEventListener('click', () => {
                    if (running) return;
                    running = true;
                    if (!cssW || !cssH) resize(); // ensure canvas is sized
                    x = Math.min(Math.max(radius + 2, x), cssW - radius - 2);
                    raf = requestAnimationFrame(draw);
                });
                animStopBtn.addEventListener('click', () => {
                    running = false;
                    if (raf) cancelAnimationFrame(raf);
                    raf = null;
                });

                window.addEventListener('resize', () => {
                    const wasRunning = running;
                    resize();
                    if (!wasRunning) draw();
                });

                // initial layout: ensure canvas sizes and draws immediately
                setTimeout(() => {
                    resize();
                    draw();
                }, 50); // delay to ensure DOM is ready
                if (demoStatus) demoStatus.textContent += ' | Animation demo ready';
                if (demoStatus) demoStatus.textContent += ' | Animation demo ready';
            })();

            // --- Save / Load / Capture demo ---
            (function setupSaveLoad() {
                const saveCanvas = document.getElementById('saveLoadCanvas2') || document.getElementById('saveLoadCanvas');
                const saveBtn = document.getElementById('saveImgBtn2') || document.getElementById('saveImgBtn');
                const loadInput = document.getElementById('loadImgInput2') || document.getElementById('loadImgInput');
                const captureBtn = document.getElementById('captureRegionBtn2') || document.getElementById('captureRegionBtn');
                const capturedCanvas = document.getElementById('capturedCanvas2') || document.getElementById('capturedCanvas');
                if (!saveCanvas || !saveBtn || !loadInput || !captureBtn || !capturedCanvas) return;

                const ctxS = saveCanvas.getContext('2d');
                const ctxC = capturedCanvas.getContext('2d');
                let cssW = 0, cssH = 0, dpr = 1;

                function resize() {
                    dpr = window.devicePixelRatio || 1;
                    cssW = saveCanvas.clientWidth;
                    cssH = saveCanvas.clientHeight;
                    saveCanvas.width = Math.max(1, Math.floor(cssW * dpr));
                    saveCanvas.height = Math.max(1, Math.floor(cssH * dpr));
                    ctxS.setTransform(dpr, 0, 0, dpr, 0, 0);

                    const ccw = capturedCanvas.clientWidth;
                    const cch = capturedCanvas.clientHeight;
                    // set captured canvas bitmap to match CSS size * dpr for crispness
                    capturedCanvas.width = Math.max(1, Math.floor(ccw * dpr));
                    capturedCanvas.height = Math.max(1, Math.floor(cch * dpr));
                    ctxC.setTransform(dpr, 0, 0, dpr, 0, 0);

                    drawSample();
                }

                function drawSample() {
                    // draw example using CSS coordinates
                    ctxS.clearRect(0, 0, cssW, cssH);
                    ctxS.fillStyle = '#eef2ff';
                    ctxS.fillRect(0, 0, cssW, cssH);
                    ctxS.fillStyle = '#f97316';
                    ctxS.fillRect(20, 20, 80, 50);
                    ctxS.fillStyle = '#06b6d4';
                    ctxS.beginPath(); ctxS.arc(cssW - 60, 50, 30, 0, Math.PI * 2); ctxS.fill();
                    ctxS.fillStyle = '#111827';
                    ctxS.font = 'bold 14px sans-serif';
                    ctxS.fillText('Sample Scene', 20, cssH - 20);
                }

                saveBtn.addEventListener('click', () => {
                    try {
                        const data = saveCanvas.toDataURL('image/png');
                        const a = document.createElement('a');
                        a.href = data; a.download = 'canvas-image.png'; document.body.appendChild(a); a.click(); a.remove();
                    } catch (err) {
                        console.error(err);
                        if (demoStatus) demoStatus.textContent += ' | Save failed (canvas may be tainted by cross-origin image)';
                    }
                });

                // load user-provided file
                loadInput.addEventListener('change', (ev) => {
                    const file = ev.target.files && ev.target.files[0];
                    if (!file) return;
                    const img = new Image();
                    img.onload = () => {
                        ctxS.clearRect(0, 0, cssW, cssH);
                        ctxS.drawImage(img, 0, 0, cssW, cssH);
                    };
                    img.onerror = () => { if (demoStatus) demoStatus.textContent += ' | Could not load chosen image'; };
                    img.src = URL.createObjectURL(file);
                });


                // capture center region using getImageData for correct device-pixel handling
                captureBtn.addEventListener('click', () => {
                    try {
                        const devW = saveCanvas.width; // device pixels
                        const devH = saveCanvas.height;
                        const wDev = Math.min(Math.floor(devW * 0.5), devW);
                        const hDev = Math.min(Math.floor(devH * 0.5), devH);
                        const sx = Math.floor((devW - wDev) / 2);
                        const sy = Math.floor((devH - hDev) / 2);
                        const imgData = ctxS.getImageData(sx / dpr, sy / dpr, wDev / dpr, hDev / dpr);
                        // size captured canvas to device pixels for clarity
                        capturedCanvas.width = Math.max(1, Math.floor((wDev / dpr) * dpr));
                        capturedCanvas.height = Math.max(1, Math.floor((hDev / dpr) * dpr));
                        ctxC.setTransform(dpr, 0, 0, dpr, 0, 0);
                        // putImageData expects full resolution; scale by dpr is already handled
                        ctxC.putImageData(imgData, 0, 0);
                    } catch (err) {
                        console.error(err);
                        if (demoStatus) demoStatus.textContent += ' | Capture failed';
                    }
                });

                window.addEventListener('resize', resize);
                // delay to ensure DOM is ready, then draw
                setTimeout(() => {
                    resize();
                }, 50);
                if (demoStatus) demoStatus.textContent += ' | Save/Load demo ready';
            })();

            // --- Bubble Sort visualization (localized redraw) ---
            (function setupBubbleSort() {
                const canvas = document.getElementById('bubbleSortCanvas');
                const startBtn = document.getElementById('startBubbleBtn');
                const stopBtn = document.getElementById('stopBubbleBtn');
                const shuffleBtn = document.getElementById('shuffleBubbleBtn');
                const steps = document.getElementById('bubbleSteps');
                if (!canvas || !startBtn || !stopBtn || !shuffleBtn || !steps) return;

                const ctx = canvas.getContext('2d');
                const valuesEl = document.getElementById('bubbleValues');
                let arr = [];
                let N = 36; // number of bars
                let running = false;
                let speed = 80; // ms delay

                function resize() {
                    const dpr = window.devicePixelRatio || 1;
                    const cssW = canvas.clientWidth || canvas.parentElement.clientWidth;
                    const cssH = canvas.clientHeight || 160;
                    canvas.width = Math.max(1, Math.floor(cssW * dpr));
                    canvas.height = Math.max(1, Math.floor(cssH * dpr));
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                    drawAll();
                }

                function makeArray() {
                    arr = Array.from({ length: N }, (_, i) => Math.floor((i + 1) / N * 100) + 4);
                }

                function shuffleArray() {
                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                    if (valuesEl) valuesEl.textContent = arr.join(', ');
                }

                function clearBar(i, padding = 2) {
                    const w = canvas.clientWidth / N || 10;
                    const x = i * w;
                    ctx.clearRect(x - padding, 0, w + padding * 2, canvas.clientHeight);
                }

                function drawBar(i, color) {
                    const w = canvas.clientWidth / N || 10;
                    const barW = Math.max(2, w * 0.85);
                    const x = i * w + (w - barW) / 2;
                    const h = (arr[i] / 104) * (canvas.clientHeight - 10);
                    const y = canvas.clientHeight - h;
                    ctx.fillStyle = color || '#f59e0b';
                    ctx.fillRect(x, y, barW, h);
                    // outline
                    ctx.strokeStyle = '#ffffff22';
                    ctx.strokeRect(x, y, barW, h);
                }

                function drawAll(highlights = {}) {
                    // full redraw (used on resize); otherwise callers will erase/draw locally
                    ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
                    for (let i = 0; i < arr.length; i++) {
                        const color = highlights[i] || '#f59e0b';
                        drawBar(i, color);
                    }
                }

                function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

                async function bubbleSortAnimate() {
                    running = true;
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    steps.innerHTML = '';
                    const n = arr.length;
                    for (let i = 0; i < n - 1 && running; i++) {
                        for (let j = 0; j < n - 1 - i && running; j++) {
                            // highlight comparison
                            clearBar(j); clearBar(j + 1);
                            drawBar(j, '#fde68a'); // compare color (amber-200)
                            drawBar(j + 1, '#fde68a');
                            steps.innerHTML += `Compare index ${j} and ${j + 1}<br>`;
                            steps.scrollTop = steps.scrollHeight;
                            await sleep(speed);

                            if (arr[j] > arr[j + 1]) {
                                // swap visually using localized redraw
                                steps.innerHTML += `Swap ${arr[j]} and ${arr[j + 1]}<br>`;
                                const tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp;
                                // erase both and redraw swapped values
                                clearBar(j); clearBar(j + 1);
                                drawBar(j, '#f97316'); // swap color (orange)
                                drawBar(j + 1, '#f97316');
                                await sleep(speed);
                            }

                            // restore normal color for these bars
                            clearBar(j); clearBar(j + 1);
                            drawBar(j); drawBar(j + 1);
                            await sleep(Math.max(10, speed / 3));
                        }
                    }

                    running = false;
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    steps.innerHTML += 'Sorting complete.';
                }

                startBtn.addEventListener('click', () => {
                    if (running) return;
                    bubbleSortAnimate().catch(err => console.error(err));
                });

                // ensure Show C Code button works for this demo (fallback if global handler misses it)
                const localShowBtn = document.querySelector('.show-code[data-code="bubblesort"]');
                if (localShowBtn) {
                    localShowBtn.addEventListener('click', () => {
                        const tc = document.getElementById('tcCode');
                        if (!tc) return;
                        const bubbleLocal = `#include <graphics.h>
#include <conio.h>
#include <stdlib.h>

// Simple Bubble Sort visualization (conceptual BGI example)
// - drawBars() draws vertical bars for each array element
// - inner loop highlights compared bars, erases them, swaps data, and redraws only the affected bars

void drawBar(int i, int value, int N, int width, int height) {
    int x = i * width + 2;
    int h = (value * height) / 104;
    setfillstyle(SOLID_FILL, YELLOW);
    bar(x, height - h, x + width - 4, height);
}

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    int N = 30;
    int arr[30];
    for (int i = 0; i < N; i++) arr[i] = (i + 1) * 3 + 5;
    // shuffle (simple)
    for (int i = N - 1; i > 0; i--) {
        int j = rand() % (i + 1);
        int t = arr[i]; arr[i] = arr[j]; arr[j] = t;
    }

    int width = getmaxx() / N;
    int height = getmaxy() - 20;

    // initial draw
    for (int i = 0; i < N; i++) drawBar(i, arr[i], N, width, height);

    for (int i = 0; i < N - 1; i++) {
        for (int j = 0; j < N - 1 - i; j++) {
            // highlight comparison
            setcolor(RED);
            rectangle(j * width + 2, height - (arr[j] * height) / 104, j * width + width - 2, height);
            rectangle((j+1) * width + 2, height - (arr[j+1] * height) / 104, (j+1) * width + width - 2, height);
            delay(80);

            if (arr[j] > arr[j+1]) {
                // swap values
                int t = arr[j]; arr[j] = arr[j+1]; arr[j+1] = t;
                // localized redraw: erase and draw only the two bars
                setfillstyle(SOLID_FILL, BLACK);
                bar(j * width + 2, 0, j * width + width - 2, height);
                bar((j+1) * width + 2, 0, (j+1) * width + width - 2, height);
                drawBar(j, arr[j], N, width, height);
                drawBar(j+1, arr[j+1], N, width, height);
                delay(80);
            }
            // restore color
            setcolor(WHITE);
        }
    }

    getch();
    closegraph();
    return 0;
`;
                        const bcLocal = document.getElementById('bubbleCode');
                        if (tc) tc.textContent = bubbleLocal;
                        if (bcLocal) bcLocal.textContent = bubbleLocal;
                    });
                }

                stopBtn.addEventListener('click', () => {
                    running = false;
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    steps.innerHTML += ' | Stopped by user.';
                });

                shuffleBtn.addEventListener('click', () => {
                    if (running) return;
                    shuffleArray();
                    drawAll();
                    steps.innerHTML = 'Shuffled array.';
                });

                // initialize
                makeArray();
                shuffleArray();
                if (valuesEl) valuesEl.textContent = arr.join(', ');
                setTimeout(resize, 50);
                window.addEventListener('resize', resize);
                stopBtn.disabled = true;
            })();

            // --- Show Code handler: use template literals so newlines are preserved correctly ---
            (function setupCodeViewer() {
                const codeDisplay = document.getElementById('tcCode');
                document.querySelectorAll('.show-code').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const which = btn.getAttribute('data-code');
                        let code = '';

                        const animCode = `#include <graphics.h>
#include <conio.h>

void drawDisk(int x, int y, int r, int color) {
    setfillstyle(SOLID_FILL, color);
    circle(x, y, r);
    floodfill(x, y, color);
}

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");
    int x = 50, vx = 5;
    while(!kbhit()) {
        cleardevice();
        drawDisk(x, 100, 20, RED);
        delay(50);
        x += vx;
        if (x > getmaxx() - 20 || x < 20) vx = -vx;
    }
    closegraph();
    return 0;
}`;

                        const saveCode = `#include <graphics.h>
#include <stdio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");
    // draw sample scene
    setcolor(RED); rectangle(20,20,100,70);
    setcolor(BLUE); circle(200,50,30);

    // capture a region (pseudo)
    void *buf = malloc( getmaxx() * getmaxy() ); // simplified
    getimage(20,20,220,120, buf);
    // write buf to file (platform-specific)
    // FILE *f = fopen("image.bin","wb"); fwrite(buf, size, 1, f); fclose(f);

    // restore
    putimage(300,20, buf, COPY_PUT);

    getch();
    closegraph();
    return 0;
}`;

                        const hanoiCode = `#include <graphics.h>
#include <conio.h>

void drawPeg(int x) { line(x, 50, x, 200); }
void drawDisk(int x, int y, int w, int color) { setfillstyle(SOLID_FILL,color); rectangle(x-w/2,y-w/4,x+w/2,y+w/4); floodfill(x,y,color); }

void hanoi(int n, int from, int to, int aux) {
    if (n>0) {
        hanoi(n-1, from, aux, to); // move disk from->to
        // draw move (pseudo)
        hanoi(n-1, aux, to, from);
    }
}

int main(){ int gd=DETECT,gm; initgraph(&gd,&gm,"");
    // setup and call hanoi with draw calls inside
    getch(); closegraph(); return 0; }`;

                        const primitivesCode = `/* Simple implementations of basic drawing primitives
 * for educational purposes (Turbo-C style graphics.h)
 */

#include <graphics.h>
#include <conio.h>

/* putpixel: draw a single pixel at (x,y) with color */
void my_putpixel(int x, int y, int color) {
    putpixel(x, y, color);
}

/* line: Bresenham's line algorithm */
void my_line(int x0, int y0, int x1, int y1, int color) {
    int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    int err = dx + dy, e2;
    while (1) {
        putpixel(x0, y0, color);
        if (x0 == x1 && y0 == y1) break;
        e2 = 2 * err;
        if (e2 >= dy) { err += dy; x0 += sx; }
        if (e2 <= dx) { err += dx; y0 += sy; }
    }
}

/* rectangle: draw rectangle outline using lines */
void my_rectangle(int x1, int y1, int x2, int y2, int color) {
    my_line(x1, y1, x2, y1, color);
    my_line(x2, y1, x2, y2, color);
    my_line(x2, y2, x1, y2, color);
    my_line(x1, y2, x1, y1, color);
}

/* circle: midpoint circle algorithm */
void my_circle(int xc, int yc, int r, int color) {
    int x = 0, y = r;
    int d = 1 - r;
    while (x <= y) {
        putpixel(xc + x, yc + y, color);
        putpixel(xc - x, yc + y, color);
        putpixel(xc + x, yc - y, color);
        putpixel(xc - x, yc - y, color);
        putpixel(xc + y, yc + x, color);
        putpixel(xc - y, yc + x, color);
        putpixel(xc + y, yc - x, color);
        putpixel(xc - y, yc - x, color);
        if (d < 0) {
            d = d + 2*x + 3;
        } else {
            d = d + 2*(x - y) + 5;
            y--;
        }
        x++;
    }
}

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    /* Example: draw primitives */
    my_putpixel(50, 40, RED);
    my_line(20, 20, 120, 60, BLUE);
    my_rectangle(140, 20, 220, 80, GREEN);
    my_circle(300, 50, 30, YELLOW);

    getch();
    closegraph();
    return 0;
}
`;

                        const putpixelCode = `#include <graphics.h>
int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");
    putpixel(50, 50, RED);
    getch();
    closegraph();
    return 0;
}`;
                        const lineCode = `#include <graphics.h>
int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");
    line(20, 20, 120, 60);
    getch();
    closegraph();
    return 0;
}`;
                        const rectCode = `#include <graphics.h>
int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");
    rectangle(140, 20, 220, 80);
    getch();
    closegraph();
    return 0;
}`;
                        const circleCode = `#include <graphics.h>
int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");
    circle(80, 50, 30);
    getch();
    closegraph();
    return 0;
}`;
                        const bubbleSortCode = `#include <graphics.h>
#include <conio.h>
#include <stdlib.h>

// Simple Bubble Sort visualization (conceptual BGI example)
// - drawBars() draws vertical bars for each array element
// - inner loop highlights compared bars, erases them, swaps data, and redraws only the affected bars

void drawBar(int i, int value, int N, int width, int height) {
    int x = i * width + 2;
    int h = (value * height) / 104;
    setfillstyle(SOLID_FILL, YELLOW);
    bar(x, height - h, x + width - 4, height);
}

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    int N = 30;
    int arr[30];
    for (int i = 0; i < N; i++) arr[i] = (i + 1) * 3 + 5;
    // shuffle (simple)
    for (int i = N - 1; i > 0; i--) {
        int j = rand() % (i + 1);
        int t = arr[i]; arr[i] = arr[j]; arr[j] = t;
    }

    int width = getmaxx() / N;
    int height = getmaxy() - 20;

    // initial draw
    for (int i = 0; i < N; i++) drawBar(i, arr[i], N, width, height);

    for (int i = 0; i < N - 1; i++) {
        for (int j = 0; j < N - 1 - i; j++) {
            // highlight comparison
            setcolor(RED);
            rectangle(j * width + 2, height - (arr[j] * height) / 104, j * width + width - 2, height);
            rectangle((j+1) * width + 2, height - (arr[j+1] * height) / 104, (j+1) * width + width - 2, height);
            delay(80);

            if (arr[j] > arr[j+1]) {
                // swap values
                int t = arr[j]; arr[j] = arr[j+1]; arr[j+1] = t;
                // localized redraw: erase and draw only the two bars
                setfillstyle(SOLID_FILL, BLACK);
                bar(j * width + 2, 0, j * width + width - 2, height);
                bar((j+1) * width + 2, 0, (j+1) * width + width - 2, height);
                drawBar(j, arr[j], N, width, height);
                drawBar(j+1, arr[j+1], N, width, height);
                delay(80);
            }
            // restore color
            setcolor(WHITE);
        }
    }

    getch();
    closegraph();
    return 0;
}`;

                        switch (which) {
                            case 'anim': code = animCode; break;
                            case 'save': code = saveCode; break;
                            case 'bubblesort': code = bubbleSortCode; break;
                            case 'hanoi': code = hanoiCode; break;
                            case 'primitives': code = primitivesCode; break;
                            case 'putpixel': code = putpixelCode; break;
                            case 'line': code = lineCode; break;
                            case 'rectangle': code = rectCode; break;
                            case 'circle': code = circleCode; break;
                            default: code = '// No example available.';
                        }

                        if (codeDisplay) codeDisplay.textContent = code;
                        // also populate the local bubble code pane when requested
                        if (which === 'bubblesort') {
                            const bc = document.getElementById('bubbleCode');
                            if (bc) bc.textContent = code;
                        }

                        // local plotting area
                        const plottingCode = document.getElementById('plottingCode');
                        const plottingPreview = document.getElementById('plottingPreview');
                        if (plottingCode) {
                            if (which === 'putpixel') plottingCode.textContent = putpixelCode;
                            else if (which === 'line') plottingCode.textContent = lineCode;
                            else if (which === 'rectangle') plottingCode.textContent = rectCode;
                            else if (which === 'circle') plottingCode.textContent = circleCode;
                            else plottingCode.textContent = '// Click a function to view a short example.';
                        }
                        if (plottingPreview) {
                            plottingPreview.innerHTML = '';
                            if (which === 'putpixel') {
                                plottingPreview.innerHTML = '<svg width="100%" height="80" viewBox="0 0 160 80" xmlns="http://www.w3.org/2000/svg"><rect width="100%" height="100%" fill="#fff7ed" rx="4"/><rect x="20" y="30" width="3" height="3" fill="#dc2626" /><text x="20" y="18" font-size="11" fill="#334155">putpixel(x,y,color) — single pixel</text></svg>';
                            } else if (which === 'line') {
                                plottingPreview.innerHTML = '<svg width="100%" height="80" viewBox="0 0 160 80" xmlns="http://www.w3.org/2000/svg"><rect width="100%" height="100%" fill="#f0f9ff" rx="4"/><line x1="10" y1="60" x2="150" y2="20" stroke="#2563eb" stroke-width="2" /><text x="10" y="12" font-size="11" fill="#334155">line(x1,y1,x2,y2) — straight line</text></svg>';
                            } else if (which === 'rectangle') {
                                plottingPreview.innerHTML = '<svg width="100%" height="80" viewBox="0 0 200 80" xmlns="http://www.w3.org/2000/svg"><rect width="100%" height="100%" fill="#f0fff4" rx="4"/><rect x="30" y="18" width="100" height="44" fill="none" stroke="#059669" stroke-width="2" rx="3" /><text x="30" y="12" font-size="11" fill="#334155">rectangle(x1,y1,x2,y2) — rectangle outline</text></svg>';
                            } else if (which === 'circle') {
                                plottingPreview.innerHTML = '<svg width="100%" height="80" viewBox="0 0 160 80" xmlns="http://www.w3.org/2000/svg"><rect width="100%" height="100%" fill="#fff7ed" rx="4"/><circle cx="80" cy="40" r="24" fill="none" stroke="#f59e0b" stroke-width="2" /><text x="10" y="12" font-size="11" fill="#334155">circle(x,y,r) — circle outline</text></svg>';
                            } else if (which === 'primitives') {
                                plottingPreview.innerHTML = '<svg width="100%" height="120" viewBox="0 0 360 120" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet"><rect width="100%" height="100%" fill="#fffbf0" rx="6"/><rect x="44" y="34" width="4" height="4" fill="#dc2626" /><text x="20" y="20" font-size="11" fill="#334155">putpixel()</text><line x1="20" y1="40" x2="120" y2="70" stroke="#2563eb" stroke-width="2" /><text x="20" y="95" font-size="11" fill="#334155">line()</text><rect x="140" y="20" width="80" height="60" fill="none" stroke="#059669" stroke-width="2" rx="2" /><text x="140" y="95" font-size="11" fill="#334155">rectangle()</text><circle cx="300" cy="50" r="30" fill="none" stroke="#f59e0b" stroke-width="2" /><text x="280" y="95" font-size="11" fill="#334155">circle()</text></svg>';
                            }
                        }

                        // global primitive preview (right under tcCode)
                        const preview = document.getElementById('primitivePreview');
                        if (preview) {
                            if (which === 'primitives') {
                                preview.classList.remove('hidden');
                                preview.innerHTML = '<svg width="100%" height="120" viewBox="0 0 360 120" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet"><rect width="100%" height="100%" fill="#fffbf0" rx="6"/><rect x="44" y="34" width="4" height="4" fill="#dc2626" /><text x="20" y="20" font-size="11" fill="#334155">putpixel()</text><line x1="20" y1="40" x2="120" y2="70" stroke="#2563eb" stroke-width="2" /><text x="20" y="95" font-size="11" fill="#334155">line()</text><rect x="140" y="20" width="80" height="60" fill="none" stroke="#059669" stroke-width="2" rx="2" /><text x="140" y="95" font-size="11" fill="#334155">rectangle()</text><circle cx="300" cy="50" r="30" fill="none" stroke="#f59e0b" stroke-width="2" /><text x="280" y="95" font-size="11" fill="#334155">circle()</text></svg>';
                            } else {
                                preview.classList.add('hidden');
                                preview.innerHTML = '';
                            }
                        }
                    });
                });
            })();

            // mark towers ready (if hanoi steps area exists)
            const hanoiSteps = document.getElementById('hanoi-steps-2');
            if (demoStatus && hanoiSteps) demoStatus.textContent += ' | Towers of Hanoi demo ready';
        });
    </script>
    <!-- External demo scripts (separation of concerns) -->
    <script src="anim.js"></script>
    <script src="saveload.js"></script>
    <script src="hanoi.js"></script>
    <script src="codeviewer.js"></script>
</body>
</html>
